// Generated by CoffeeScript 1.6.2
var BranchFunctions, DirectionFunctions,
  __slice = [].slice;

DirectionFunctions = (function() {
  function DirectionFunctions() {}

  DirectionFunctions.prototype.all = [0, 1, 2, 3, 4, 5, 6, 7];

  DirectionFunctions.prototype.weight = function(w, func) {
    var _this = this;

    return function(point) {
      if (_this.weightCheck(w)) {
        return func(point);
      } else {
        return _this.randomize(_this.all);
      }
    };
  };

  DirectionFunctions.prototype.random = function() {
    var _this = this;

    return function(point) {
      return _this.randomize(_this.all);
    };
  };

  DirectionFunctions.prototype.favorDirection = function(dir) {
    var _this = this;

    return function(point) {
      return _this.randomize(dir, [(dir + 1) % 8, (dir + 7) % 8]);
    };
  };

  DirectionFunctions.prototype.trendToCenter = function() {
    var _this = this;

    return function(point) {
      return _this.favorDirection(point.directionTo(point.grid.center))(point);
    };
  };

  DirectionFunctions.prototype.x = function(width) {
    var _this = this;

    return function(point) {
      if (Math.abs(point.x - point.y) <= width || point.grid.width - (point.x + point.y) <= width) {
        return _this.favorDirection((point.directionTo(point.grid.center) + 4) % 8)(point);
      } else {
        return _this.randomize(_this.all);
      }
    };
  };

  DirectionFunctions.prototype.explode = function() {
    var _this = this;

    return function(point) {
      return _this.favorDirection((point.directionTo(point.grid.center) + 4) % 8)(point);
    };
  };

  DirectionFunctions.prototype.jagged = function() {
    var _this = this;

    return function(point) {
      return _this.randomize([1, 3, 5, 7]);
    };
  };

  DirectionFunctions.prototype.squarish = function() {
    var _this = this;

    return function(point) {
      return _this.randomize([0, 2, 4, 6]);
    };
  };

  DirectionFunctions.prototype.inertia = function(mutationRate) {
    var _this = this;

    return function(point) {
      var dir;

      dir = point.grid.currDirection;
      if (_this.weightCheck(mutationRate)) {
        point.grid.currDirection = Math.random() < 0.5 ? dir - 1 : dir + 1;
      }
      return _this.favorDirection(point.grid.currDirection)(point);
    };
  };

  DirectionFunctions.prototype.bounce = function(startDir) {
    var _this = this;

    return function(point) {
      var grid;

      grid = point.grid;
      if (point.y === 0) {
        if (grid.currDirection === 7) {
          grid.currDirection = 5;
        }
        if (grid.currDirection === 1) {
          grid.currDirection = 3;
        }
        if (grid.currDirection === 0) {
          grid.currDirection = 4;
        }
      } else if (point.y >= grid.height - 1) {
        if (grid.currDirection === 5) {
          grid.currDirection = 7;
        }
        if (grid.currDirection === 3) {
          grid.currDirection = 1;
        }
        if (grid.currDirection === 4) {
          grid.currDirection = 0;
        }
      }
      if (point.x === 0) {
        if (grid.currDirection === 5) {
          grid.currDirection = 3;
        }
        if (grid.currDirection === 6) {
          grid.currDirection = 2;
        }
        if (grid.currDirection === 7) {
          grid.currDirection = 1;
        }
      } else if (point.x >= grid.width - 1) {
        if (grid.currDirection === 3) {
          grid.currDirection = 5;
        }
        if (grid.currDirection === 2) {
          grid.currDirection = 6;
        }
        if (grid.currDirection === 1) {
          grid.currDirection = 7;
        }
      }
      return _this.favorDirection(grid.currDirection)(point);
    };
  };

  DirectionFunctions.prototype.weightCheck = function(weight) {
    return Math.random() < weight;
  };

  DirectionFunctions.prototype.randomize = function() {
    var a, all, e, elem, g, groups, res, shuffle, _i, _j, _k, _len, _len1, _len2;

    groups = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    shuffle = function(list) {
      var k, n, temp;

      n = list.length;
      while (n > 1) {
        k = Math.floor(Math.random() * n--);
        temp = list[n];
        list[n] = list[k];
        list[k] = temp;
      }
      return list;
    };
    all = new Set(0, 1, 2, 3, 4, 5, 6, 7);
    res = [];
    for (_i = 0, _len = groups.length; _i < _len; _i++) {
      g = groups[_i];
      if (g instanceof Array) {
        shuffle(g);
        for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
          elem = g[_j];
          res.push(elem);
          all.remove(elem);
        }
      } else {
        res.push(g);
        all.remove(g);
      }
    }
    a = all.toArray();
    shuffle(a);
    for (_k = 0, _len2 = a.length; _k < _len2; _k++) {
      e = a[_k];
      res.push(e);
    }
    return res;
  };

  return DirectionFunctions;

})();

BranchFunctions = (function() {
  function BranchFunctions() {}

  BranchFunctions.prototype.random = function() {
    var _this = this;

    return function(grid) {
      return grid.drawn.randomElement();
    };
  };

  BranchFunctions.prototype.fromStart = function() {
    var _this = this;

    return function(grid) {
      return grid.drawn.findFirst(function(p) {
        return p.openNeighbors().length() > 0;
      });
    };
  };

  BranchFunctions.prototype.fromEnd = function() {
    var _this = this;

    return function(grid) {
      return grid.drawn.findLast(function(p) {
        return p.openNeighbors().length() > 0;
      });
    };
  };

  return BranchFunctions;

})();
