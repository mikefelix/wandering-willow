// Generated by CoffeeScript 1.4.0
var Grid,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {

  function Grid(opts) {
    this.drawOne = __bind(this.drawOne, this);

    this.draw = __bind(this.draw, this);

    this.init = __bind(this.init, this);

    this.checkSurrounded = __bind(this.checkSurrounded, this);

    this.drawLine = __bind(this.drawLine, this);

    this.markDrawn = __bind(this.markDrawn, this);

    this.markSurrounded = __bind(this.markSurrounded, this);

    this.debug = __bind(this.debug, this);

    this.done = __bind(this.done, this);

    this.findBranchPoint = __bind(this.findBranchPoint, this);

    this.hasSurrounded = __bind(this.hasSurrounded, this);

    this.hasDrawn = __bind(this.hasDrawn, this);
    this.canvas = opts['canvas'];
    this.cellSize = opts['cellSize'];
    this.getDirection = opts['getDirection'];
    this.width = Math.floor(this.canvas.width / this.cellSize);
    this.height = Math.floor(this.canvas.height / this.cellSize);
    this.center = new Point(Math.floor(this.width / 2), Math.floor(this.height / 2), this);
    this.drawn = new Set();
    this.surrounded = new Set();
    this.count = 0;
    this.init();
  }

  Grid.prototype.hasDrawn = function(point) {
    return (point != null) && this.drawn.contains(point);
  };

  Grid.prototype.hasSurrounded = function(point) {
    return (point != null) && this.surrounded.contains(point);
  };

  Grid.prototype.findBranchPoint = function() {
    return this.drawn.randomElement();
  };

  Grid.prototype.done = function() {
    return this.count >= (this.width + 1) * (this.height + 1);
  };

  Grid.prototype.debug = function(where, msg) {
    var elem, v;
    elem = $(where);
    if (!(elem != null)) {
      return;
    }
    v = where === 'news' ? elem.value : '';
    return elem.value += v + msg;
  };

  Grid.prototype.markSurrounded = function(point) {
    this.drawn.remove(point);
    return this.surrounded.add(point);
  };

  Grid.prototype.markDrawn = function(point) {
    if (!this.hasDrawn(point) && !this.hasSurrounded(point)) {
      this.drawn.add(point);
      return this.count += 1;
    }
  };

  Grid.prototype.drawLine = function(origin, dest) {
    var _this = this;
    this.c.beginPath();
    this.c.moveTo(origin.realX, origin.realY);
    this.c.lineTo(dest.realX, dest.realY);
    this.c.closePath();
    this.c.stroke();
    this.c.stroke();
    this.markDrawn(origin);
    this.markDrawn(dest);
    origin.connections.add(dest);
    this.checkSurrounded(dest);
    return dest.neighbors().each(function(n) {
      return _this.checkSurrounded(n);
    });
  };

  Grid.prototype.checkSurrounded = function(point) {
    if (this.hasDrawn(point) && !this.hasSurrounded(point) && point.openNeighbors().length() === 0) {
      return this.markSurrounded(point);
    }
  };

  Grid.prototype.init = function() {
    this.c = this.canvas.getContext('2d');
    this.c.lineWidth = 1;
    this.c.strokeStyle = 'black';
    this.origin = this.center;
    return this.markDrawn(this.origin);
  };

  Grid.prototype.draw = function() {
    this.init();
    return this.drawOne();
  };

  Grid.prototype.drawOne = function() {
    var dest, _ref;
    if (this.done()) {
      alert("Finished!");
      return;
    }
    while (!((_ref = this.origin) != null ? _ref.branchable() : void 0)) {
      this.origin = this.findBranchPoint();
    }
    dest = this.origin.findOpenNeighbor(this.getDirection);
    if (!(dest != null)) {
      alert("No dest found!");
      return;
    }
    this.drawLine(this.origin, dest);
    this.origin = dest;
    return setTimeout(this.drawOne, 0);
  };

  return Grid;

})();
