// Generated by CoffeeScript 1.4.0
var Grid,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {

  function Grid(opts) {
    this.drawOne = __bind(this.drawOne, this);

    this.draw = __bind(this.draw, this);

    this.init = __bind(this.init, this);

    this.checkSurrounded = __bind(this.checkSurrounded, this);

    this.drawLine = __bind(this.drawLine, this);

    this.findOpenNeighbor = __bind(this.findOpenNeighbor, this);

    this.markDrawn = __bind(this.markDrawn, this);

    this.markSurrounded = __bind(this.markSurrounded, this);

    this.debug = __bind(this.debug, this);

    this.done = __bind(this.done, this);

    this.findBranchPoint = __bind(this.findBranchPoint, this);

    this.hasSurrounded = __bind(this.hasSurrounded, this);

    this.hasDrawn = __bind(this.hasDrawn, this);

    this.point = __bind(this.point, this);
    this.canvas = opts['canvas'];
    this.cellSize = opts['cellSize'];
    this.getDirection = opts['getDirection'];
    this.drawn = new Set();
    this.surrounded = new Set();
    this.points = {};
    this.count = 0;
    this.width = Math.floor(this.canvas.width / this.cellSize);
    this.height = Math.floor(this.canvas.height / this.cellSize);
    this.center = this.point(Math.floor(this.width / 2), Math.floor(this.height / 2));
    this.init();
    this.triggered = false;
  }

  Grid.prototype.point = function(x, y) {
    var _base, _name;
    return (_base = this.points)[_name = x + '/' + y] || (_base[_name] = new Point(x, y, this));
  };

  Grid.prototype.hasDrawn = function(point) {
    return (point != null) && this.drawn.contains(point);
  };

  Grid.prototype.hasSurrounded = function(point) {
    return (point != null) && this.surrounded.contains(point);
  };

  Grid.prototype.findBranchPoint = function() {
    return this.drawn.randomElement();
  };

  Grid.prototype.done = function() {
    return this.count >= (this.width + 1) * (this.height + 1);
  };

  Grid.prototype.debug = function(where, msg) {
    var elem, v;
    elem = $(where);
    if (!(elem != null)) {
      return;
    }
    v = where === 'news' ? elem.value : '';
    return elem.value += v + msg;
  };

  Grid.prototype.markSurrounded = function(point) {
    this.drawn.remove(point);
    return this.surrounded.add(point);
  };

  Grid.prototype.markDrawn = function(point) {
    if (!this.hasDrawn(point) && !this.hasSurrounded(point)) {
      this.drawn.add(point);
      return this.count += 1;
    }
  };

  Grid.prototype.findOpenNeighbor = function(point) {
    var i, neighbor, openNeighbors, start, _i;
    if (point instanceof Array) {
      point = this.point(point[0], point[1]);
    }
    if (this.hasSurrounded(point)) {
      return null;
    }
    openNeighbors = point.openNeighbors();
    start = this.getDirection(point, this);
    for (i = _i = 0; _i <= 7; i = ++_i) {
      neighbor = point.neighborAt((start + i) % 8);
      if (point.neighborIsOpen(neighbor)) {
        return neighbor;
      }
    }
    return null;
  };

  Grid.prototype.drawLine = function(origin, dest) {
    var _this = this;
    if (!(origin != null) || !(dest != null)) {
      alert("Null point");
    }
    if (origin instanceof Array) {
      origin = this.point(origin[0], origin[1]);
    }
    if (dest instanceof Array) {
      dest = this.point(dest[0], dest[1]);
    }
    this.c.beginPath();
    this.c.moveTo(origin.realX, origin.realY);
    this.c.lineTo(dest.realX, dest.realY);
    this.c.closePath();
    this.c.stroke();
    this.c.stroke();
    this.markDrawn(origin);
    this.markDrawn(dest);
    origin.connections.add(dest);
    this.checkSurrounded(dest);
    return dest.neighbors().each(function(n) {
      return _this.checkSurrounded(n);
    });
  };

  Grid.prototype.checkSurrounded = function(point) {
    var a;
    if (this.triggered) {
      a = 1;
    }
    if (this.hasDrawn(point) && !this.hasSurrounded(point) && point.openNeighbors().length() === 0) {
      return this.markSurrounded(point);
    }
  };

  Grid.prototype.init = function() {
    this.c = this.canvas.getContext('2d');
    this.c.lineWidth = 1;
    this.c.strokeStyle = 'black';
    this.origin = this.center;
    return this.markDrawn(this.origin);
  };

  Grid.prototype.draw = function() {
    this.init();
    return this.drawOne();
  };

  Grid.prototype.drawOne = function() {
    var dest, _ref;
    if (this.done()) {
      alert("Finished!");
      return;
    }
    dest = null;
    while (!((_ref = this.origin) != null ? _ref.branchable() : void 0)) {
      this.origin = this.findBranchPoint();
      if (!(this.origin != null)) {
        alert("Can't find branch point.");
        return;
      }
      dest = this.findOpenNeighbor(this.origin, this.getDirection);
      if (!(dest != null)) {
        this.origin = null;
      }
    }
    while (!(dest != null)) {
      dest = this.findOpenNeighbor(this.origin, this.getDirection);
    }
    this.drawLine(this.origin, dest);
    this.origin = dest;
    return setTimeout(this.drawOne, 0);
  };

  return Grid;

})();
