// Generated by CoffeeScript 1.4.0
var Grid,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {

  function Grid(opts) {
    this.drawOne = __bind(this.drawOne, this);

    this.draw = __bind(this.draw, this);

    this.checkSurrounded = __bind(this.checkSurrounded, this);

    this.drawLine = __bind(this.drawLine, this);

    this.findOpenNeighbor = __bind(this.findOpenNeighbor, this);

    this.markDrawn = __bind(this.markDrawn, this);

    this.markSurrounded = __bind(this.markSurrounded, this);

    this.done = __bind(this.done, this);

    this.hasSurrounded = __bind(this.hasSurrounded, this);

    this.hasDrawn = __bind(this.hasDrawn, this);

    this.point = __bind(this.point, this);

    this.init = __bind(this.init, this);
    this.canvas = opts['canvas'];
    this.cellSize = opts['cellSize'];
    this.getDirections = opts['getDirections'];
    this.getBranchPoint = opts['getBranchPoint'];
    this.strokeStyle = opts['strokeStyle'];
    this.currDirection = Math.floor(Math.random() * 8);
    this.width = Math.floor(this.canvas.width / this.cellSize);
    this.height = Math.floor(this.canvas.height / this.cellSize);
    this.init();
  }

  Grid.prototype.init = function() {
    this.c = this.canvas.getContext('2d');
    this.c.lineWidth = 1;
    this.c.strokeStyle = this.strokeStyle;
    this.drawn = new Set();
    this.surrounded = new Set();
    this.points = {};
    this.count = 0;
    this.center = this.point(Math.floor(this.width / 2), Math.floor(this.height / 2));
    this.origin = this.center;
    return this.markDrawn(this.origin);
  };

  Grid.prototype.point = function(x, y) {
    var _base, _name;
    return (_base = this.points)[_name = x + '/' + y] || (_base[_name] = new Point(x, y, this));
  };

  Grid.prototype.hasDrawn = function(point) {
    return (point != null) && this.drawn.contains(point);
  };

  Grid.prototype.hasSurrounded = function(point) {
    return (point != null) && this.surrounded.contains(point);
  };

  Grid.prototype.done = function() {
    return this.count >= this.width * this.height;
  };

  Grid.prototype.markSurrounded = function(point) {
    this.drawn.remove(point);
    return this.surrounded.add(point);
  };

  Grid.prototype.markDrawn = function(point) {
    if (!this.hasDrawn(point) && !this.hasSurrounded(point)) {
      this.drawn.add(point);
      return this.count += 1;
    }
  };

  Grid.prototype.findOpenNeighbor = function(point) {
    var i, neighbor, openNeighbors, _i, _len, _ref;
    if (point instanceof Array) {
      point = this.point(point[0], point[1]);
    }
    if (this.hasSurrounded(point)) {
      return null;
    }
    openNeighbors = point.openNeighbors();
    _ref = this.getDirections(point);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      neighbor = point.neighborAt(i);
      if ((neighbor != null) && point.neighborIsOpen(neighbor)) {
        this.currDirection = i;
        return neighbor;
      }
    }
    return null;
  };

  Grid.prototype.drawLine = function(origin, dest) {
    var _this = this;
    if (!(origin != null) || !(dest != null)) {
      alert("Null point");
    }
    if (origin instanceof Array) {
      origin = this.point(origin[0], origin[1]);
    }
    if (dest instanceof Array) {
      dest = this.point(dest[0], dest[1]);
    }
    this.c.beginPath();
    this.c.moveTo(origin.realX, origin.realY);
    this.c.lineTo(dest.realX, dest.realY);
    this.c.closePath();
    this.c.stroke();
    this.c.stroke();
    this.markDrawn(origin);
    this.markDrawn(dest);
    origin.connections.add(dest);
    this.checkSurrounded(dest);
    return dest.neighbors().each(function(n) {
      return _this.checkSurrounded(n);
    });
  };

  Grid.prototype.checkSurrounded = function(point) {
    if (this.hasDrawn(point) && !this.hasSurrounded(point) && point.openNeighbors().length() === 0) {
      return this.markSurrounded(point);
    }
  };

  Grid.prototype.draw = function() {
    this.init();
    return this.drawOne();
  };

  Grid.prototype.drawOne = function() {
    var dest, _ref;
    if (this.done()) {
      return;
    }
    dest = null;
    while (!((_ref = this.origin) != null ? _ref.branchable() : void 0)) {
      this.origin = this.getBranchPoint(this);
      if (!(this.origin != null)) {
        alert("Can't find branch point.");
        return;
      }
      dest = this.findOpenNeighbor(this.origin);
      if (!(dest != null)) {
        this.origin = null;
      }
    }
    while (!(dest != null)) {
      dest = this.findOpenNeighbor(this.origin);
    }
    this.drawLine(this.origin, dest);
    this.origin = dest;
    return setTimeout(this.drawOne, 0);
  };

  return Grid;

})();
