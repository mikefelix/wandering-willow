// Generated by CoffeeScript 1.6.2
var Grid,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {
  function Grid(canvas) {
    this.canvas = canvas;
    this.draw = __bind(this.draw, this);
    this.drawOne = __bind(this.drawOne, this);
    this.drawLoop = __bind(this.drawLoop, this);
    this.drawLine = __bind(this.drawLine, this);
    this.findOpenNeighbor = __bind(this.findOpenNeighbor, this);
    this.markDrawn = __bind(this.markDrawn, this);
    this.markSurrounded = __bind(this.markSurrounded, this);
    this.checkSurrounded = __bind(this.checkSurrounded, this);
    this.done = __bind(this.done, this);
    this.hasSurrounded = __bind(this.hasSurrounded, this);
    this.hasDrawn = __bind(this.hasDrawn, this);
    this.point = __bind(this.point, this);
    this.init = __bind(this.init, this);
    this.directionFunctions = new DirectionFunctions();
    this.branchFunctions = new BranchFunctions();
  }

  Grid.prototype.init = function(opts) {
    if ((typeof window !== "undefined" && window !== null) && (window.drawTimer != null)) {
      clearTimeout(window.drawTimer);
    }
    this.c = this.canvas.getContext('2d');
    this.c.lineWidth = 1;
    this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.strokeStyle = opts['strokeStyle'] || 'white';
    this.cellSize = opts['cellSize'] || 10;
    this.currDirection = Math.floor(Math.random() * 8);
    this.width = Math.floor(this.canvas.width / this.cellSize);
    this.height = Math.floor(this.canvas.height / this.cellSize);
    this.getDirections = this.getDirectionFunc(opts);
    this.getBranchPoint = this.branchFunctions[opts['branchStyle']]();
    this.maxBranchAge = parseInt(opts['branchTtl']);
    if (opts['fillPercent'] != null) {
      this.fillPercent = parseFloat(opts['fillPercent']);
    }
    if (opts['maxBranchCount'] != null) {
      this.maxBranchCount = parseInt(opts['maxBranchCount']);
    }
    if (opts['onDone'] != null) {
      this.onDone = opts['onDone'];
    }
    this.drawn = new Set();
    this.surrounded = new Set();
    this.points = {};
    this.branchCount = 0;
    this.count = 0;
    this.branchAge = 0;
    this.center = this.point(Math.floor(this.width / 2), Math.floor(this.height / 2));
    this.origin = this.center;
    this.markDrawn(this.origin);
    return this.finish = false;
  };

  Grid.prototype.getDirectionFunc = function(opts) {
    var arg, func, style, weight;

    style = opts['directionStyle'];
    arg = (function() {
      switch (style) {
        case 'favorDirection':
          return opts['direction'];
        case 'bounce':
          return opts['direction'];
        case 'x':
          return opts['width'];
        case 'inertia':
          return opts['mutation'];
        default:
          return null;
      }
    })();
    func = this.directionFunctions[style](arg);
    if (opts['randomization'] != null) {
      weight = Math.abs(parseFloat(opts['randomization']) - 1);
      func = this.directionFunctions.weight(weight, func);
    }
    return func;
  };

  Grid.prototype.getStrokeStyle = function() {
    var hex, num, step;

    if (typeof this.strokeStyle === 'function') {
      return this.strokeStyle();
    }
    if (this.strokeStyle === 'fade') {
      step = 256 / this.maxBranchAge;
      num = 255 - parseInt(this.branchAge * step);
      hex = num.toString(16);
      if (hex.length === 1) {
        hex = '0' + hex;
      }
      return '#' + hex + hex + hex;
    } else {
      return this.strokeStyle;
    }
  };

  Grid.prototype.point = function(x, y) {
    var _base, _name;

    return (_base = this.points)[_name = x + '/' + y] || (_base[_name] = new Point(x, y, this));
  };

  Grid.prototype.hasDrawn = function(point) {
    return (point != null) && this.drawn.contains(point);
  };

  Grid.prototype.hasSurrounded = function(point) {
    return (point != null) && this.surrounded.contains(point);
  };

  Grid.prototype.done = function() {
    var d;

    d = this.finish ? true : this.maxBranchCount != null ? this.branchCount >= this.maxBranchCount : this.fillPercent != null ? this.count >= this.width * this.height * this.fillPercent : this.count >= this.width * this.height;
    if (d && (this.onDone != null)) {
      this.onDone();
    }
    return d;
  };

  Grid.prototype.checkSurrounded = function(point) {
    if (this.hasDrawn(point) && !this.hasSurrounded(point) && point.openNeighbors().length() === 0) {
      return this.markSurrounded(point);
    }
  };

  Grid.prototype.markSurrounded = function(point) {
    this.drawn.remove(point);
    return this.surrounded.add(point);
  };

  Grid.prototype.markDrawn = function(point) {
    if (!this.hasDrawn(point) && !this.hasSurrounded(point)) {
      this.drawn.add(point);
      return this.count += 1;
    }
  };

  Grid.prototype.findOpenNeighbor = function(point) {
    var i, neighbor, openNeighbors, _i, _len, _ref;

    if (point instanceof Array) {
      point = this.point(point[0], point[1]);
    }
    if (this.hasSurrounded(point)) {
      return null;
    }
    openNeighbors = point.openNeighbors();
    _ref = this.getDirections(point);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      neighbor = point.neighborAt(i);
      if ((neighbor != null) && point.neighborIsOpen(neighbor)) {
        this.currDirection = i;
        return neighbor;
      }
    }
    return null;
  };

  Grid.prototype.drawLine = function(origin, dest) {
    var _this = this;

    if ((origin == null) || (dest == null)) {
      alert("Null point");
    }
    if (origin instanceof Array) {
      origin = this.point(origin[0], origin[1]);
    }
    if (dest instanceof Array) {
      dest = this.point(dest[0], dest[1]);
    }
    this.c.strokeStyle = this.getStrokeStyle();
    this.c.beginPath();
    this.c.moveTo(origin.realX, origin.realY);
    this.c.lineTo(dest.realX, dest.realY);
    this.c.closePath();
    this.c.stroke();
    this.c.stroke();
    this.markDrawn(origin);
    this.markDrawn(dest);
    origin.connections.add(dest);
    this.checkSurrounded(dest);
    dest.neighbors().each(function(n) {
      return _this.checkSurrounded(n);
    });
    if (this.drawn.length() !== Object.keys(this.drawn.elements).length || this.drawn.length() !== this.drawn.order.length) {
      return alert(this.drawn.length() + ' / ' + Object.keys(this.drawn.elements).length + ' / ' + this.drawn.order.length);
    }
  };

  Grid.prototype.drawLoop = function() {
    if (this.drawOne()) {
      return window.drawTimeout = setTimeout(this.drawLoop, 0);
    }
  };

  Grid.prototype.drawOne = function() {
    var bCount, dest, _ref;

    if (this.done()) {
      return true;
    }
    dest = null;
    while (!((_ref = this.origin) != null ? _ref.branchable() : void 0) || ((this.maxBranchAge != null) && this.branchAge >= this.maxBranchAge)) {
      this.branchAge = 0;
      this.branchCount++;
      if (this.done()) {
        return true;
      }
      bCount = bCount != null ? bCount + 1 : 1;
      if (bCount > 1000) {
        alert('Infinite loop while finding branch.');
        return false;
      }
      this.origin = this.getBranchPoint(this);
      if (this.origin == null) {
        alert("Can't find branch point.");
        return false;
      }
      dest = this.findOpenNeighbor(this.origin);
      if (dest == null) {
        this.origin = null;
      }
    }
    while (dest == null) {
      dest = this.findOpenNeighbor(this.origin);
    }
    this.drawLine(this.origin, dest);
    this.origin = dest;
    this.branchAge++;
    return true;
  };

  Grid.prototype.draw = function(opts) {
    this.init(opts);
    return this.drawLoop();
  };

  return Grid;

})();
