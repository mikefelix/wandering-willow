// Generated by CoffeeScript 1.4.0
var Grid,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {

  function Grid(canvas, cellSize, getDirection) {
    this.canvas = canvas;
    this.cellSize = cellSize;
    this.getDirection = getDirection != null ? getDirection : DirectionFunctions.random();
    this.drawOne = __bind(this.drawOne, this);

    this.draw = __bind(this.draw, this);

    this.checkSurrounded = __bind(this.checkSurrounded, this);

    this.drawLine = __bind(this.drawLine, this);

    this.markDrawn = __bind(this.markDrawn, this);

    this.markSurrounded = __bind(this.markSurrounded, this);

    this.debug = __bind(this.debug, this);

    this.done = __bind(this.done, this);

    this.findBranchPoint = __bind(this.findBranchPoint, this);

    this.hasSurrounded = __bind(this.hasSurrounded, this);

    this.hasDrawn = __bind(this.hasDrawn, this);

    this.windowHeight = window.innerHeight;
    this.windowWidth = window.innerWidth;
    this.canvas.width = this.canvas.style.width = windowWidth;
    this.canvas.height = this.canvas.style.height = windowHeight;
    this.pixelWidth = parseInt(this.canvas.style.width.replace(/\D/, ''));
    this.pixelHeight = parseInt(this.canvas.style.height.replace(/\D/, ''));
    this.center = new Point(Math.floor(this.width / 2), Math.floor(this.height / 2), this);
    this.width = Math.floor(this.pixelWidth / this.cellSize);
    this.height = Math.floor(this.pixelHeight / this.cellSize);
    this.count = 0;
    this.drawn = new Set();
    this.surrounded = new Set();
  }

  Grid.prototype.hasDrawn = function(point) {
    return !(point != null) || this.drawn.contains(point);
  };

  Grid.prototype.hasSurrounded = function(point) {
    return this.surrounded.contains(point);
  };

  Grid.prototype.findBranchPoint = function() {
    return this.drawn.randomElement();
  };

  Grid.prototype.done = function() {
    return this.count >= (this.width + 1) * (this.height + 1);
  };

  Grid.prototype.debug = function(where, msg) {
    var elem, v;
    elem = $(where);
    if (!(elem != null)) {
      return;
    }
    v = where === 'news' ? elem.value : '';
    return elem.value += v + msg;
  };

  Grid.prototype.markSurrounded = function(point) {
    if (!this.surrounded.contains(point)) {
      this.drawn.remove(point);
      return this.surrounded.add(point);
    }
  };

  Grid.prototype.markDrawn = function(point) {
    if (!this.drawn.contains(point) && !this.surrounded.contains(point)) {
      this.drawn.add(point);
      return this.count += 1;
    }
  };

  Grid.prototype.drawLine = function(origin, dest) {
    var n, _i, _len, _ref, _results;
    this.c.beginPath();
    this.c.moveTo(origin.realX, origin.realY);
    this.c.lineTo(dest.realX, dest.realY);
    this.c.closePath();
    this.c.stroke();
    this.c.stroke();
    this.markDrawn(origin);
    this.markDrawn(dest);
    origin.connections.add(dest);
    this.checkSurrounded(dest);
    _ref = dest.neighbors();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      _results.push(this.checkSurrounded(n));
    }
    return _results;
  };

  Grid.prototype.checkSurrounded = function(point) {
    if ((point != null ? point.drawn() : void 0) && !point.surrounded()) {
      if (point.neighbors().any(function(p) {
        return !this.hasDrawn(p);
      })) {
        return this.markSurrounded(point);
      }
    }
  };

  Grid.prototype.draw = function() {
    this.c = this.canvas.getContext('2d');
    this.c.lineWidth = 1;
    this.c.strokeStyle = 'black';
    this.origin = this.center;
    this.markDrawn(this.origin);
    return this.drawOne();
  };

  Grid.prototype.drawOne = function() {
    var dest, _ref;
    if (this.done()) {
      return 'Finished!';
    }
    while (!((_ref = this.origin) != null ? _ref.branchable() : void 0)) {
      this.origin = this.findBranchPoint();
    }
    dest = this.origin.findOpenNeighbor(this.getDirection);
    if (!(dest != null)) {
      return;
    }
    this.drawLine(this.origin, dest);
    this.origin = dest;
    return setTimeout(this.drawOne, 0);
  };

  return Grid;

})();
