// Generated by CoffeeScript 1.4.0
(function() {
  var Point,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Point = (function() {

    function Point(x, y, grid) {
      this.grid = grid;
      this.findOpenNeighbor = __bind(this.findOpenNeighbor, this);

      this.wouldIntersect = __bind(this.wouldIntersect, this);

      this.neighborAt = __bind(this.neighborAt, this);

      this.getDirectionTo = __bind(this.getDirectionTo, this);

      this.openNeighbors = __bind(this.openNeighbors, this);

      this.neighbors = __bind(this.neighbors, this);

      this.branchable = __bind(this.branchable, this);

      this.surrounded = __bind(this.surrounded, this);

      this.drawn = __bind(this.drawn, this);

      this.toString = __bind(this.toString, this);

      this.x = parseInt(x);
      this.y = parseInt(y);
      this.realX = this.x * this.grid.cellSize + 1;
      this.realY = this.y * this.grid.cellSize + 1;
      this.connections = new Set();
    }

    Point.prototype.toString = function() {
      return this.x + '/' + this.y;
    };

    Point.prototype.drawn = function() {
      return this.grid.hasDrawn(this);
    };

    Point.prototype.surrounded = function() {
      return this.grid.hasSurrounded(this);
    };

    Point.prototype.branchable = function() {
      return !this.surrounded();
    };

    Point.prototype.neighbors = function() {
      var dir, _i, _results;
      _results = [];
      for (dir = _i = 0; _i <= 7; dir = ++_i) {
        _results.push(neighborAt(dir));
      }
      return _results;
    };

    Point.prototype.openNeighbors = function() {
      var dir, _i, _results;
      _results = [];
      for (dir = _i = 0; _i <= 7; dir = ++_i) {
        if (!neighborAt(dir).drawn()) {
          _results.push(neighborAt(dir));
        }
      }
      return _results;
    };

    Point.prototype.getDirectionTo = function(dest) {
      if (this.x === dest.x && this.y > dest.y) {
        return 0;
      }
      if (this.x < dest.x && this.y > dest.y) {
        return 1;
      }
      if (this.x < dest.x && this.y === dest.y) {
        return 2;
      }
      if (this.x < dest.x && this.y < dest.y) {
        return 3;
      }
      if (this.x === dest.x && this.y < dest.y) {
        return 4;
      }
      if (this.x > dest.x && this.y < dest.y) {
        return 5;
      }
      if (this.x > dest.x && this.y === dest.y) {
        return 6;
      }
      if (this.x > dest.x && this.y > dest.y) {
        return 7;
      }
      throw "Can't find direction to " + dest.toString();
    };

    Point.prototype.neighborAt = function(dir) {
      var _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7;
      switch (dir) {
        case 0:
          if (y > 0) {
            return (_base = this.neighbors)[0] || (_base[0] = new Point(x, y - 1, this.grid));
          }
          break;
        case 1:
          if (x < grid.width && y > 0) {
            return (_base1 = this.neighbors)[1] || (_base1[1] = new Point(x + 1, y - 1, this.grid));
          }
          break;
        case 2:
          if (x < grid.width) {
            return (_base2 = this.neighbors)[2] || (_base2[2] = new Point(x + 1, y, this.grid));
          }
          break;
        case 3:
          if (x < grid.width && y < grid.height) {
            return (_base3 = this.neighbors)[3] || (_base3[3] = new Point(x + 1, y + 1, this.grid));
          }
          break;
        case 4:
          if (y < grid.height) {
            return (_base4 = this.neighbors)[4] || (_base4[4] = new Point(x, y + 1, this.grid));
          }
          break;
        case 5:
          if (x > 0 && y < grid.height) {
            return (_base5 = this.neighbors)[5] || (_base5[5] = new Point(x - 1, y + 1, this.grid));
          }
          break;
        case 6:
          if (x > 0) {
            return (_base6 = this.neighbors)[6] || (_base6[6] = new Point(x - 1, y, this.grid));
          }
          break;
        case 7:
          if (x > 0 && y > 0) {
            return (_base7 = this.neighbors)[7] || (_base7[7] = new Point(x - 1, y - 1, this.grid));
          }
      }
      return null;
    };

    Point.prototype.wouldIntersect = function(dest, dir) {
      var intersector1, intersector2;
      if (dir % 2 !== 1) {
        return false;
      }
      intersector1 = this.neighborAt((dir + 1) % 8);
      intersector2 = this.neighborAt((dir - 1) % 8);
      return intersector1.connections.contains(intersector2) || intersector2.connections.contains(intersector1);
    };

    Point.prototype.findOpenNeighbor = function(getStartDirection) {
      var dir, i, point, start, _i;
      if (this.surrounded()) {
        return null;
      }
      start = getStartDirection(this);
      for (i = _i = 0; _i <= 7; i = ++_i) {
        dir = (start + i) % 8;
        point = this.neighborAt(dir);
        if ((point != null) && !this.wouldIntersect(point, dir)) {
          return point;
        }
      }
    };

    return Point;

  })();

}).call(this);
