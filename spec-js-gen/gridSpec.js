// Generated by CoffeeScript 1.4.0
var drawAndCheck;

drawAndCheck = function(grid, from, to, expectDrawn, expectSurrounded, block) {
  if (block == null) {
    block = null;
  }
  grid.drawLine(new Point(from[0], from[1], grid), new Point(to[0], to[1], grid));
  expect(grid.drawn.length()).toEqual(expectDrawn);
  expect(grid.surrounded.length()).toEqual(expectSurrounded);
  if (block != null) {
    expect(block()).toEqual(true);
  }
  return to;
};

describe("Grid", function() {
  beforeEach(function() {
    var canvas, context;
    context = {
      lineWidth: 10,
      strokeStyle: '',
      beginPath: function() {},
      moveTo: function(x, y) {},
      lineTo: function(x, y) {},
      closePath: function() {},
      stroke: function() {}
    };
    canvas = {
      width: 100,
      height: 100,
      getContext: function() {
        return context;
      }
    };
    return this.g = new Grid({
      canvas: canvas,
      cellSize: 10,
      getDirection: DirectionFunctions.random()
    });
  });
  it('can surround cells', function() {
    var _this = this;
    this.g.drawn.add(new Point(5, 5, this.g));
    this.g.drawn.add(new Point(5, 6, this.g));
    this.g.drawn.add(new Point(6, 6, this.g));
    this.g.drawn.add(new Point(6, 5, this.g));
    this.g.drawn.add(new Point(6, 4, this.g));
    this.g.drawn.add(new Point(5, 4, this.g));
    this.g.drawn.add(new Point(4, 4, this.g));
    this.g.drawn.add(new Point(4, 5, this.g));
    this.g.checkSurrounded(new Point(5, 5, this.g));
    expect(this.g.hasSurrounded(new Point(5, 5, this.g))).toEqual(false);
    this.g.drawn.add(new Point(4, 6, this.g));
    expect(new Point(5, 5, this.g).neighbors().all(function(p) {
      return _this.g.hasDrawn(p);
    })).toEqual(true);
    this.g.checkSurrounded(new Point(5, 5, this.g));
    return expect(this.g.hasSurrounded(new Point(5, 5, this.g))).toEqual(true);
  });
  it('detects intersection', function() {
    expect(this.g.origin.toString()).toEqual(new Point(5, 5, this.g).toString());
    drawAndCheck(this.g, [5, 5], [6, 6], 2, 0);
    drawAndCheck(this.g, [6, 6], [6, 5], 3, 0);
    expect(new Point(6, 5, this.g).wouldIntersect(new Point(5, 6, this.g))).toEqual(true);
    return expect(new Point(6, 5, this.g).wouldIntersect(new Point(7, 5, this.g))).toEqual(false);
  });
  it('keeps track of drawn cells', function() {
    var _this = this;
    expect(this.g.origin.toString()).toEqual(new Point(5, 5, this.g).toString());
    drawAndCheck(this.g, [5, 5], [5, 6], 2, 0);
    drawAndCheck(this.g, [5, 6], [6, 6], 3, 0);
    drawAndCheck(this.g, [6, 6], [6, 5], 4, 0);
    drawAndCheck(this.g, [6, 5], [6, 4], 5, 0);
    drawAndCheck(this.g, [6, 4], [5, 4], 6, 0);
    drawAndCheck(this.g, [5, 4], [4, 4], 7, 0);
    drawAndCheck(this.g, [4, 4], [4, 5], 8, 0);
    return drawAndCheck(this.g, [4, 5], [4, 6], 8, 1, function() {
      return _this.g.surrounded.contains(new Point(5, 5, _this.g));
    });
  });
  return it("doesn't overlap lines", function() {
    var p,
      _this = this;
    p = [5, 5];
    p = drawAndCheck(this.g, p, [4, 6], 2, 0);
    p = drawAndCheck(this.g, p, [5, 7], 3, 0);
    p = drawAndCheck(this.g, p, [6, 6], 4, 0);
    p = drawAndCheck(this.g, p, [6, 5], 5, 0);
    return p = drawAndCheck(this.g, p, [5, 6], 5, 1, function() {
      return _this.g.surrounded.contains(new Point(5, 6, _this.g));
    });
  });
});
